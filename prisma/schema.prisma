generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(uuid())
  name      String   @db.VarChar(100)
  username  String   @unique @db.VarChar(100)
  password  String
  cpf       String
  number    String   @db.VarChar(100)
  email     String   @unique @db.VarChar(100)
  role      Role     @default(USER)
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  pagarmeCustomerId String? @unique @map("pagarme_customer_id")

  profile        Profile?
  likes          PostLike[]
  wallet         Wallet?
  savedCards     SavedCard[]
  plans          Plan[]
  singleWorkouts SingleWorkout[] // Agora um treinador pode ter múltiplas aulas avulsas
  recipientInfo  RecipientInfo?
  addresses      Address?

  trainerHorarios     TrainerHorarios?
  trainerAppointments Appointment[]    @relation("TrainerAppointments")

  transactions        Transaction[] @relation("UserTransactions")
  trainerTransactions Transaction[] @relation("TrainerTransactions")

  subscriptions        Subscription[] @relation("UserSubscriptions")
  trainerSubscriptions Subscription[] @relation("TrainerSubscriptions")

  orders        Order[] @relation("CustomerOrders")
  trainerOrders Order[] @relation("TrainerOrders")

  @@map("users")
}

model Profile {
  id                String   @id @default(uuid())
  username          String   @unique
  name              String
  address           String
  phone             String
  alunos            Int
  posts             Post[]
  description       String
  niche             String
  followers         Int
  rate              Float
  avatar            String
  marketImage       String?
  formation         String?
  specialty         String?
  onlineService     String?
  presencialService String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  user User @relation(fields: [username], references: [username])

  @@map("user_infos")
}

model Address {
  id             Int      @id @default(autoincrement())
  userId         String   @unique @map("user_id")
  street         String
  complementary  String?
  streetNumber   String   @map("street_number")
  neighborhood   String
  city           String
  state          String   @db.VarChar(2)
  zipCode        String   @map("zip_code")
  referencePoint String?  @map("reference_point")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  // Relations
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  recipientInfo RecipientInfo[]

  @@map("addresses")
}

model RecipientInfo {
  id     Int    @id @default(autoincrement())
  userId String @unique @map("user_id")

  // Address reference
  addressId Int @map("address_id")

  // Personal information
  siteUrl                String? @map("site_url")
  motherName             String? @map("mother_name")
  birthdate              String // Mantendo como String para compatibilidade com formato DD/MM/YYYY
  monthlyIncome          Int?    @map("monthly_income") // em centavos
  professionalOccupation String? @map("professional_occupation")

  // Bank account information
  bankHolderName     String @map("bank_holder_name")
  bankHolderType     String @default("individual") @map("bank_holder_type")
  bankHolderDocument String @map("bank_holder_document")
  bank               String // Código do banco
  branchNumber       String @map("branch_number")
  branchCheckDigit   String @map("branch_check_digit")
  accountNumber      String @map("account_number")
  accountCheckDigit  String @map("account_check_digit")
  accountType        String @default("checking") @map("account_type")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  address Address @relation(fields: [addressId], references: [id])

  @@map("recipient_infos")
}

model Appointment {
  id        Int      @id @default(autoincrement())
  trainerId String   @map("trainer_id")
  studentId String?  @map("student_id")
  location  Json // Objeto location com type, name, address
  date      DateTime @db.Timestamptz(3)
  notes     String

  // Status da aula
  status      String    @default("pending") // pending, accepted, rejected, completed, cancelled, no_show
  acceptedAt  DateTime? @map("accepted_at")
  rejectedAt  DateTime? @map("rejected_at")
  completedAt DateTime? @map("completed_at")

  // Status do pagamento
  paymentStatus String    @default("pending") // pending, paid, refunded
  paidAt        DateTime? @map("paid_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Tipo de agendamento - mutuamente exclusivos
  subscriptionId  String? @map("subscription_id") // Para agendamentos via assinatura
  singleWorkoutId Int?    @map("single_workout_id") // Para agendamentos de aula avulsa

  trainer User @relation("TrainerAppointments", fields: [trainerId], references: [id], onDelete: Cascade)

  // Relacionamentos baseados no tipo de agendamento
  subscription  Subscription?  @relation(fields: [subscriptionId], references: [id])
  singleWorkout SingleWorkout? @relation(fields: [singleWorkoutId], references: [id])
  Plan          Plan?          @relation(fields: [planId], references: [id])
  planId        String?

  @@index([trainerId])
  @@index([date])
  @@index([studentId])
  @@index([subscriptionId])
  @@index([singleWorkoutId])
  @@index([status]) // Índice para filtrar por status da aula
  @@index([paymentStatus]) // Índice para filtrar por status do pagamento
  @@map("appointments")
}

model Post {
  id        String    @id @default(uuid())
  profileId String    @map("profile_id")
  caption   String?   @db.Text
  mediaUrl  String    @map("media_url")
  mediaType MediaType @map("media_type")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  profile Profile    @relation(fields: [profileId], references: [id], onDelete: Cascade)
  likes   PostLike[]

  @@index([profileId, createdAt])
  @@map("posts")
}

model PostLike {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  postId    String   @map("post_id")
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId]) // cada user pode curtir 1x
  @@index([postId])
  @@index([userId])
  @@map("post_likes")
}

model TrainerHorarios {
  id                    Int      @id @default(autoincrement())
  trainerId             String   @unique
  horarios              Json
  savedLocations        Json?
  defaultLocationConfig Json?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  trainer User @relation(fields: [trainerId], references: [id], onDelete: Cascade)

  @@map("trainer_horarios")
}

// === SISTEMA DE PAGAMENTOS ===

model Wallet {
  id              Int      @id @default(autoincrement())
  userId          String   @unique @map("user_id")
  pagarmeWalletId String?  @unique @map("pagarme_wallet_id")
  balance         Int      @default(0) // em centavos
  lastSynced      DateTime @default(now()) @map("last_synced")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("wallet")
}

model SavedCard {
  id             Int      @id @default(autoincrement())
  userId         String   @map("user_id")
  pagarmeCardId  String   @unique @map("pagarme_card_id")
  lastFour       String   @map("last_four")
  brand          String
  holderName     String   @map("holder_name")
  holderDocument String   @default("") @map("holder_document")
  expMonth       Int      @default(0) @map("exp_month")
  expYear        Int      @default(0) @map("exp_year")
  lastFourDigits String   @default("") @map("last_four_digits")
  firstSixDigits String   @default("") @map("first_six_digits")
  status         String   @default("") @map("status")
  type           String
  isDefault      Boolean  @default(false) @map("is_default")
  createdAt      DateTime @default(now()) @map("created_at")
  updatedAt      DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("saved_cards")
}

model Plan {
  id              String   @id @default(uuid())
  trainerUsername String   @map("trainer_username")
  trainerId       String   @map("trainer_id")
  pagarmePlanId   String   @unique @map("pagarme_plan_id")
  name            String
  description     String?
  category        String?
  price           Int // em centavos
  features        Json? // array de features do plano
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  trainer       User           @relation(fields: [trainerId], references: [id], onDelete: Cascade)
  subscriptions Subscription[]
  Appointment   Appointment[]

  @@index([trainerUsername, isActive, trainerId])
  @@map("plans")
}

model Subscription {
  id                    String             @id @default(uuid())
  userId                String             @map("user_id")
  trainerId             String             @map("trainer_id")
  planId                String             @map("plan_id")
  pagarmeSubscriptionId String             @unique @map("pagarme_subscription_id")
  status                SubscriptionStatus @default(ACTIVE)
  planPrice             Int                @map("plan_price") // em centavos
  startDate             DateTime           @map("start_date")
  endDate               DateTime?          @map("end_date")
  createdAt             DateTime           @default(now()) @map("created_at")
  updatedAt             DateTime           @updatedAt @map("updated_at")
  appointments          Appointment[] // <- APENAS ESTA LINHA NOVA

  user    User @relation("UserSubscriptions", fields: [userId], references: [id], onDelete: Cascade)
  trainer User @relation("TrainerSubscriptions", fields: [trainerId], references: [id], onDelete: Cascade)
  plan    Plan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([trainerId])
  @@index([status])
  @@map("subscriptions")
}

model SingleWorkout {
  id              Int      @id @default(autoincrement())
  trainerUsername String   @map("trainer_username")
  trainerId       String   @map("trainer_id")
  name            String
  description     String?
  category        String?
  price           Int
  duration        Int? // Duração em minutos
  isActive        Boolean  @default(true) @map("is_active")
  createdAt       DateTime @default(now()) @map("created_at")
  updatedAt       DateTime @updatedAt @map("updated_at")

  trainer      User          @relation(fields: [trainerId], references: [id], onDelete: Cascade)
  appointments Appointment[]

  @@index([trainerId, isActive])
  @@index([trainerUsername, isActive])
  @@index([category])
  @@map("single_workouts")
}

model Order {
  id          String @id @default(uuid())
  customerId  String @map("customer_id")
  trainerId   String @map("trainer_id")
  orderNumber String @unique @map("order_number") // Número sequencial amigável

  // Total
  totalAmount Int @map("total_amount") // em centavos

  // Status e pagamento
  status        String
  paymentMethod String? @map("payment_method")

  // Pagamentos
  pagarmeOrderId String? @unique @map("pagarme_order_id")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  customer User @relation("CustomerOrders", fields: [customerId], references: [id], onDelete: Cascade)
  trainer  User @relation("TrainerOrders", fields: [trainerId], references: [id], onDelete: Cascade)

  @@index([customerId])
  @@index([trainerId])
  @@index([status])
  @@index([createdAt])
  @@map("orders")
}

model Transaction {
  id            Int             @id @default(autoincrement())
  userId        String?         @map("user_id") // quem fez o pagamento
  trainerId     String?         @map("trainer_id") // quem recebeu
  orderId       String?         @map("order_id") // ID da ordem no Pagar.me
  transferId    String?         @map("transfer_id") // ID da transferência no Pagar.me
  amount        Int // em centavos
  type          TransactionType
  status        String?
  paymentMethod String?         @map("payment_method") // credit_card, pix, etc
  description   String?
  createdAt     DateTime        @default(now()) @map("created_at")
  updatedAt     DateTime        @updatedAt @map("updated_at")

  user    User? @relation("UserTransactions", fields: [userId], references: [id], onDelete: SetNull)
  trainer User? @relation("TrainerTransactions", fields: [trainerId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([trainerId])
  @@index([type])
  @@index([createdAt])
  @@map("transactions")
}

// === ENUMS ===

enum MediaType {
  IMAGE
  VIDEO
}

enum Role {
  USER
  ADMIN
  TRAINER
}

enum TransactionType {
  PAYMENT // pagamento de aula ou assinatura
  WITHDRAWAL // saque
  REFUND // estorno
  FEE // taxa da plataforma 
}

enum SubscriptionStatus {
  ACTIVE // ativa
  CANCELLED // cancelada
  EXPIRED // expirada
  SUSPENDED // suspensa
}
